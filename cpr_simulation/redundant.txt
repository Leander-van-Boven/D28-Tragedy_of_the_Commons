        "agent" : {
            "metabolism" : 2,               # The 'cost' of staying alive per epoch (in energy)
            "procreate_req" : 16,           # The amount of energy an agent needs to have before it can create offspring
            "procreate_cost" : 10,          # The amount of energy it costs to create a new child
            "maximum_age" : 100,           # The maximum age for the agent, the agent gets 'removed' when its age exceeds this parameter
        },

        # if self.growth_func == 0:
        #     self.amount += self.amount * self.growth_rate
        # elif self.growth_func == 1:
        #     self.amount += self.amount
        # elif self.growth_func == 2:
        #     self.amount += math.sqrt(self.max_amount - self.amount) 



OLD ARGPARSE W/ SCENARIO PATH INSTEAD OF NAME:
if args.command=='run':
    if args.path:
    try:
        if os.path.isdir(args.path):
            loc = f'{args.path}\\params.json'
            with open(args.path+'\\params.json', 'r') as file:
                param_dict = json.loads(file.read())
        elif os.path.isfile(args.path):
            loc = args.path
            with open(args.path, 'r') as file:
                param_dict = json.loads(file.read())
    except FileNotFoundError:
        print('Parameter file not found: %s' % loc)
        sys.exit(1)
    TODO: Catch more errors if needed
# Load correct scenario if provided
if args.scenario != None:
    with open(args.scenario, 'r') as file:
        param_dict = json.loads(file.read())

elif args.command=='save':
        if args.path and os.path.isdir(args.path):
            path = args.path
        else:
            i=0
            while(os.path.isfile('run'+i+'.py')):
                i+=1
            path = 'run'+i+'.py'

        if nobp.copy_last_run(path):
            print('Saved last run to', path)
        else:
            print('No run to save :(')



MAIN.PY DECIDE WHAT PARAMS TO USE:
        # if not os.path.isfile('.defaults.json'):
        #     generate_default_params()
        # generate_default_params()
        # with open('.defaults.json', 'r') as file:
        #     s = file.read()
        # params = json.loads(s)

def test():
    a = {
        "a" : 1,
        "b" : {
            "ba" : 1,
            "bb" : 1,
        },
        "c" : 1,
    }

    b = {
        "a" : 0,
        "b" : {
            "ba" : 0,
        },
        "d" : 0
    }

    a.update(b)
    return a

            sim.get_agent_count()*self.res_limit_factor):
            # Prosocial Behaviour
            if self.social_value_orientation >= .5:
                # Agent only fishes enough to survive another day.
                if self.energy <= 0:
                    self.energy += sim.get_resource().consume_resource(
                        abs(self.energy) + 1)
            # Proself Behaviour
            else:
                # Determine if proself agent violates restriction rule.
                if self.energy>0 and rnd.random()<self.violation_chance:
                    self.energy = sim.get_resource().consume_resource(
                        self.consumption)
                    # Check whether agent is caught fishing.
                    if rnd.random() < self.caught_chance:
                        self.cur_cooldown = self.cooldown
                # Comply to restriction rule; 
                # only fish to survive another day.
                else:
                    self.energy += sim.get_resource().consume_resource(
                        abs(self.energy) + 1)


###### POSSIBLE ENERGY FUNCTION ######
# TODO implement more energy functions / behaviours
# def secondary_energy_function(self, res):
"""
Built of base model.

Accounts for deliberation time constraints based on age, hunger,
    and scarcity

These time constraints inspire increasingly greedy behaviour in
    proself agents

Additional greed coefficients are weighted at a diminishing value
"""
#
#   self.energy -= self.metabolism
#   
#   # Prosocial
#   if self.social_value_orientation >= .5:
#       self.energy += res.consume_resource(self.consumption)
#
#   # Proself
#   fish = res.get_amount()
#   population = self.simulation.get_agent_count()
#
#   scarce_bool = fish/population < self.scarcity
#   age_bool = self.age > self.elderly
#   hungry_bool = self.energy < self.hungry
#
#   if scarce_bool and age_bool and hungry_bool:
#       self.energy += res.consume_resource(
#           self.consumption*self.greed1*greed2*greed3)
#   elif (scarce_bool and age_bool) or 
#        (scarce_bool and hungry_bool) or 
#        (age_bool and hungry_bool):
#       self.energy += res.consume_resource(
#           self.consumption*self.greed1*greed2)
#   elif scare_bool or age_bool or hungry_bool:
#       self.energy += res.consume_resource(
#           self.consumption*self.greed1)
#   else:
#       self.energy += res.consume_resource(self.consumption)
#
#   self.age += 1
#   
#   ### Addition of Reproduction to the model
#   reproduce = 0
#   if self.energy > self.procreate_req:
#       reproduce += 1
#   return reproduce

# TODO
# implement high-reward high-risk functions 
#   that have possible punishments:
#   "An agent is not allowed to go fishing 
#       when the amount of fish is below x",
#   Punishment: If caught, the agent is not allowed to fish 
#       or y amount of days

# inherited_attr = [
#     'consumption', 'procreate_cost',
#     'social_value_orientation']
# def inherit(property):
#     val = ((parent1.energy*getattr(parent1,property)
#             +parent2.energy*getattr(parent2,property)) 
#            / (parent1.energy+parent2.energy))
#     setattr(child, property, val)
# for attr in inherited_attr:
#     inherit(attr)
# m_attr = rnd.choice(inherited_attr)
# mutation_factor = sim.agent_params['mutation_factor']
# m_ftr = rnd.gauss(0, mutation_factor)      
# val = max(getattr(child, m_attr) + getattr(child, m_attr)*m_ftr, 1)
# setattr(child, m_attr, val)